# LRF-SNN based AER事件驱动设计说明
设计源代码目录在*user-src-snn_ff*，仿真代码在*user-sim*。vivado工程文件在*prj/snn_pl_axi_ddr*；顶层文件为 Top.sv，顶层测试tb文件为tb_top_lrf_odins.sv，该顶层展示了一层Cin * Hin * Win，在感受野为Cin * LRF_H * LRF_W下，输出Cout * Hout * W_out的局部感受野网络，详细自定义设计参数见顶层说明。具体仿真波形结合vivado项目运行查看。**输入输出事件遵循Req-Ack协议。**
**注意：**
1. 设计参数最好选择$2^n$数值，数值过小如1，2，3，4可能会出现例化bug，多数为传参时，信号变量的位宽不匹配或超出导致出现不稳态等问题，尚未经过严格的验证不同参数设置下例化结果与仿真结果是否正常。
2. 顶层输入事件AERIN_ADDR按照{event_type, Cin, Hin, Win}进行拼接，顶层输出事件AEROUT_ADDR按照{event_type, Cout, Hout, Wout}进行拼接。注意每个拼接位单独占用位宽，如Cin=3时为2bit，因此当Cin，Hin，Win不为$2^n$时，AERIN_ADDR所能表示的事件会有冗余。
3. 单个核心的事件AER_IN_CORE_WIDTH映射方式为：输入神经元地址为{event_type, Cin, LRF_H, LRF_W}，AER_OUT_CORE_WIDTH为{event_type, Cout}。
4. 单层的核心映射方式为：Hout * Wout个核心，每个核心输出代表输出特征图像素位置的输出神经元。

5. 对于每个核心的突触权重地址映射为{Cin, LRF_H, LRF_W，Cout}，现在所用的sram模块为自定义，若需要将模型参数加载到sram中，需自行通过脚本将软件模型的权重参数，按照上述地址映射关系生成一系列的txt文件，并加载到sram中。
6. ==**模块尚未经过研究验证分析，以及代码可综合性，硬件开销分析；修改参数难免会有bug出现导致编译综合不通过，请结合实际解决。通常是位宽参数不匹配或有误；Map映射广播驱动aer_in_lrf_mapper模块想了很久才成功跑出来，但写法有点复杂，不知道综合电路开销如何，驱动结果是否完全符合预期尚未严谨验证，只是看波形判断了个基本，3*3，步长为1的感受野应该是没有问题的。**==

# 事件定义
1. 定义event_type == 2'b00，为神经元事件，会将该事件下的输入神经元所连接的所有突触权重累加到相应输出神经元中；
2. 定义event_type == 2'b01，为时间步事件，会激活所有输出神经元，在输出端发送下一层的神经元事件，输出完当前时间步下所有的神经元事件后，自动发送一个时间步事件给下一层。
3. 定义event_type == 2'b10，为推理事件，在收到T个时间步事件后，核心控制逻辑会自动进入该事件阶段；核心会按{输入神经元，输出神经元}地址历遍所有突触权重，同时对神经元状态的信息（膜电位、脉冲计数）进行更新，并根据IS_TRAIN选择是否更新权重。
4. 定义event_type == 2'b11，为无效事件，核心不做处理。
5. 每个事件所花费的时钟周期由controller中的局部参数决定，即R_W_SRAM_CLK_neur_act，R_W_SRAM_CLK_tstep_act，R_W_SRAM_CLK_tref分别代表神经元、时间步、推理的周期，具体参数可根据基本单元的打拍调整，至少为2（sram读写周期为2）
# 可自行设计修改的地方
1. 关于Goodness计算，目前针对每个核心的所有神经元的膜电位，在时间步事件的时候，分批次移动平均累加ReLU后的膜电位，每个核心对应一个AVG_GOODNESS，也就是说目前goodness是按通道局部取平均，并没有对Hout*Wout维度进行平均。
2. 在线学习算法硬件实现，在ffstdp_update.v模块中，关于梯度计算的硬件实现需要自己实现，延时过长需要打拍自行增加寄存器级数，并修改controller中的R_W_SRAM_CLK_tref参数。目前的设计是打了两拍，因此R_W_SRAM_CLK_tref=4；
3. IS_POS信号可一正一负得形式激励，1表示正样本，0表示负样本，ffstdp_update根据该信号选择梯度计算并累加。IS_TRAIN控制在推理阶段是否将累加的梯度累加到权重中，即IS_TRAIN=1时，将累加的梯度累加到权重中，并同时将累加梯度清0；IS_TRAIN=0时，则累加梯度但不加到权重上。梯度地址与权重地址一致。
4. 对于计算当前层所有时间步后再传递给下一层这个操作，暂未实现，目前仍是多层同时进行，如需要实现可在aer_core_event_arbiter.v模块对相应信号进行控制实现。
5. 如何构建多层或着单层复用需自己设计。 
6. 需要自己写实际激励测试以验证自己的模型，可在tb_top_lrf_odins.sv的基础上改，加载实际模型参数和加载实际脉冲事件流，实现思路可参考本人本科毕设的tb_odin_ffstbp.sv文件，这个文件仿真测试的是784-256全连接网络的实际数据流，

已连肝4天，要死了，已经写不动了，模块肯定是有bug的，但过几天，这会怎么写的都忘了，剩下的问题需要师姐借助AI弄和解决了，测试波形用例在vivado已经设置好了，最多修改配置下文件路径名或重新导入下就可以跑的，祝师姐毕设进度顺利。

# 波形示意图
![alt text](image.png)
# 初步综合结果
![alt text](image-1.png)
初步综合了下，每个核心主要开销如上，分析开销较大的是schduler调度器，我默认设置了128深度的fifo在里面缓冲，实际上并不需要这么多，在scheduler.v文件将对应fifo深度调小就好了，可调4-16，具体需要根据实际需求来定，这里只是给出一个参考。

其他地方没做优化了（controller部分其实还可优化），大概一个核心需要几百的lut和寄存器吧，主要资源用来存储膜电位、脉冲计数、权重、梯度了。